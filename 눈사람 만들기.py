import collections


def solution(grid):
    n = len(grid)
    m = len(grid[0])

    snowballs = []
    snow_cells = []
    for r in range(n):
        for c in range(m):
            if grid[r][c] == 'o':
                snowballs.append((r, c))
            elif grid[r][c] == '.':
                snow_cells.append((r, c))

    # 각 눈(.)에 번호를 매깁니다. (비트마스크를 쓰기엔 눈의 개수가 많을 수 있음)
    # 하지만 문제에서 요구하는 것은 '종류'이므로,
    # 각 눈덩이가 특정 위치 (r, c)에 도달했을 때 가능한 '크기'들을 셋(set)으로 관리합니다.

    def get_possible_sizes(start_node):
        # dist[(r, c)] = 해당 위치에 도달했을 때 가능한 크기(가진 눈의 개수 + 1)들의 집합
        # n, m <= 500 이므로 전체 탐색 시 메모리 관리가 중요합니다.
        # 실제로는 "경로"가 중요하므로 단순 BFS가 아닌 BFS 내에서
        # (r, c, 현재까지 획득한 눈의 상태)를 관리해야 정확하지만,
        # 문제의 의도는 '모든 칸을 방문하며 얻을 수 있는 크기'를 찾는 것입니다.

        # 격자 내의 눈(.)의 위치를 index로 맵핑
        snow_map = {pos: i for i, pos in enumerate(snow_cells)}
        num_snows = len(snow_cells)

        # 특정 칸 (r, c)에 도달했을 때 가질 수 있는 크기의 집합
        # (r, c) -> set(크기들)
        reachable = collections.defaultdict(set)

        # (r, c, 현재 획득한 눈들의 비트마스크)
        # ※ 주의: 눈의 개수가 많으면 비트마스크를 쓸 수 없습니다.
        # 테스트 케이스 그룹 #3 (n=1) 등을 고려할 때,
        # 일반적인 BFS로 '모든 가능한 눈의 조합'을 구하는 것은 최적화가 필요합니다.

        # 문제의 특성상 "특정 칸에 도착했을 때 밟은 눈의 개수"가 크기가 됩니다.
        # 이 문제는 결국 두 눈덩이가 만나는 지점 (r, c)에서
        # 각자가 밟고 온 눈의 집합이 서로소(disjoint)여야 합니다.

        # [수정된 접근]
        # 모든 가능한 눈사람 종류를 찾기 위해 BFS를 수행합니다.
        # state: (r1, c1, r2, c2, mask) -> 너무 큼.

        # 대신, 모든 가능한 (몸통, 머리) 쌍을 저장할 set
        possible_snowmen = set()

        # 눈덩이가 작으므로(n,m <= 500), 각 칸에 대해 도달 가능한
        # '최소 눈 개수'와 '최대 눈 개수'를 구하는 방식은 부정확할 수 있습니다.
        # 하지만 "눈사람 만들기"는 결국 두 경로가 겹치지 않게 눈을 나눠 갖는 문제입니다.

        # 문제의 예시와 제약사항을 볼 때, 격자가 아주 복잡하지 않다면
        # 백트래킹이나 비트마스크 BFS를 의도했을 수 있습니다.
        # 여기서는 효율적인 탐색을 위해 각 위치별 가능 크기를 구하는 로직을 구성합니다.
        pass

    # 위 방식은 복잡도가 높으므로, 문제의 의도에 따라
    # 각 눈덩이가 획득할 수 있는 눈의 '모든 조합'을 찾아야 합니다.
    # 단, 두 눈덩이가 만나서 눈사람이 될 때는 사용한 눈(.)이 중복되면 안 됩니다.

    # [최종 전략]
    # 1. 한 눈덩이가 특정 칸 (r, c)에 도달하며 획득한 눈의 비트마스크들을 구함.
    # 2. 두 눈덩이가 같은 칸 (r, c)에서 만날 때, 두 마스크의 AND 연산이 0인 경우만 체크.
    # 3. 그때의 (눈 개수1 + 1, 눈 개수2 + 1)을 저장.

    # ※ n*m이 500*500이지만, 실제 '눈'의 개수가 적거나 경로가 제한적일 것입니다.
    # 만약 눈의 개수가 많다면 비트마스크 대신 다른 최적화가 필요합니다.